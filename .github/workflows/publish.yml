# Automated build and release workflow for AlbionDataAvalonia
# Triggers: manual dispatch or push to main when workflow file changes
#
# This workflow handles cross-platform builds and releases for Windows, Linux, and macOS.
# The macOS job includes code signing and Apple notarization to ensure the app is trusted
# by macOS Gatekeeper and can run on users' machines without security warnings.
#
# REQUIRED GITHUB SECRETS:
#   - DEVELOPER_ID_CERT_BASE64: Developer ID Application certificate (base64-encoded .p12)
#   - DEVELOPER_ID_CERT_PASSWORD: Password for the .p12 certificate
#   - DEVELOPER_ID_IDENTITY: Certificate identity (e.g., "Developer ID Application: Name (TEAM_ID)")
#   - KEYCHAIN_PASSWORD: Temporary keychain password used during the build
#   - AC_API_KEY_ID: App Store Connect API key ID for notarization
#   - AC_API_ISSUER_ID: App Store Connect issuer ID (team ID)
#   - AC_API_KEY_P8_BASE64: App Store Connect API private key (base64-encoded .p8)
name: Build and Release

on:
  workflow_dispatch:
    inputs:
      draft:
        description: "Create draft release (manual runs only)"
        required: false
        default: "true"
  push:
    branches:
      - main

jobs:
  build-macos:
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Publish macOS project
        run: |
          dotnet publish ./AlbionDataAvalonia.Desktop.MacOS/AlbionDataAvalonia.Desktop.MacOS.csproj -c Release -r osx-arm64

      - name: Import Apple Developer ID certificate (temp keychain)
        env:
          DEVELOPER_ID_CERT_BASE64: ${{ secrets.DEVELOPER_ID_CERT_BASE64 }}
          DEVELOPER_ID_CERT_PASSWORD: ${{ secrets.DEVELOPER_ID_CERT_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Decode and import the Developer ID certificate to a temporary keychain.
          # This allows codesign to access the certificate during the build without
          # requiring interactive prompts or storing the cert in the system keychain.
          echo "$DEVELOPER_ID_CERT_BASE64" | base64 --decode > dev_id.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security import dev_id.p12 -k build.keychain -P "$DEVELOPER_ID_CERT_PASSWORD" -T /usr/bin/codesign
          # Allow codesign and Xcode tools to access the key without UI prompts.
          # The partition list must include apple-tool and apple to work in CI/CD.
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security list-keychains -d user -s build.keychain login.keychain
          security find-identity -p codesigning -v

      - name: Codesign macOS app (.app)
        env:
          DEVELOPER_ID_IDENTITY: ${{ secrets.DEVELOPER_ID_IDENTITY }}
        run: |
          # Code sign the entire app bundle with the Developer ID certificate.
          # Flags:
          #   --deep: Signs all nested frameworks and dylibs
          #   --options runtime: Hardened runtime to support notarization
          #   --entitlements: Apply security entitlements required for packet capture (libpcap)
          #   --timestamp: Include secure timestamp from Apple (required for notarization)
          APP_DIR="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app"
          codesign --force --deep --options runtime --entitlements packaging/macos/entitlements.plist --timestamp -s "$DEVELOPER_ID_IDENTITY" "$APP_DIR"
          # Verify the signature (|| true to continue even if there are warnings)
          codesign -dv --verbose=4 "$APP_DIR" || true

      - name: Zip app for notarization
        run: |
          APP_DIR="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app"
          ZIP_PATH="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app.zip"
          ditto -c -k --sequesterRsrc --keepParent "$APP_DIR" "$ZIP_PATH"

      - name: Submit to notarization (non-blocking)
        env:
          AC_API_KEY_ID: ${{ secrets.AC_API_KEY_ID }}
          AC_API_ISSUER_ID: ${{ secrets.AC_API_ISSUER_ID }}
          AC_API_KEY_P8_BASE64: ${{ secrets.AC_API_KEY_P8_BASE64 }}
        run: |
          # Decode the App Store Connect API key and submit the app to Apple for notarization.
          # This is a non-blocking step; we return a RequestUUID and then poll for completion.
          echo "$AC_API_KEY_P8_BASE64" | base64 --decode > AuthKey.p8
          ZIP_PATH="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app.zip"
          echo "Submitting to Apple notarization..."
          xcrun notarytool submit "$ZIP_PATH" --key AuthKey.p8 --key-id "$AC_API_KEY_ID" --issuer "$AC_API_ISSUER_ID" 2>&1 | tee notarize_result.txt
          echo "Notarization submission complete. Output saved."
          cat notarize_result.txt
      
      - name: Check notarization submission
        if: always()
        run: |
          if [ -f notarize_result.txt ]; then
            echo "=== Notarization result ==="
            cat notarize_result.txt
            if grep -q "RequestUUID" notarize_result.txt; then
              echo "✓ Submission successful (got RequestUUID)"
            else
              echo "✗ Submission may have failed or returned unexpected output"
            fi
          else
            echo "✗ Notarization result file not found"
          fi

      - name: Extract notarization Submission ID
        run: |
          if [ ! -f notarize_result.txt ]; then
            echo "notarize_result.txt not found"; exit 1;
          fi
          SUBMISSION_ID=$(sed -n 's/^[[:space:]]*id:[[:space:]]*\(.*\)$/\1/p' notarize_result.txt | head -n1)
          if [ -z "$SUBMISSION_ID" ]; then
            echo "Failed to parse Submission ID from output:"; cat notarize_result.txt; exit 1;
          fi
          echo "SUBMISSION_ID=$SUBMISSION_ID" >> "$GITHUB_ENV"
          echo "Submission ID: $SUBMISSION_ID"

      - name: Wait for notarization result (poll)
        env:
          AC_API_KEY_ID: ${{ secrets.AC_API_KEY_ID }}
          AC_API_ISSUER_ID: ${{ secrets.AC_API_ISSUER_ID }}
        run: |
          # Poll Apple's notarization service every 30 seconds (up to 60 attempts = ~30 min).
          # Notarization typically completes in 10-30 minutes; longer if there are issues.
          # We fail immediately if the submission is "invalid"; otherwise we wait for "accepted".
          ATTEMPTS=60
          SLEEP_SECS=30
          STATUS=""
          MAX_WAIT=$((ATTEMPTS * SLEEP_SECS))
          echo "Will wait up to $MAX_WAIT seconds for Apple notarization..."
          for i in $(seq 1 $ATTEMPTS); do
            ELAPSED=$((i * SLEEP_SECS))
            echo "[${ELAPSED}s/$MAX_WAIT] Polling notarization status (attempt $i/$ATTEMPTS)..."
            xcrun notarytool info "$SUBMISSION_ID" --key AuthKey.p8 --key-id "$AC_API_KEY_ID" --issuer "$AC_API_ISSUER_ID" 2>&1 | tee notary_info.txt || true
            STATUS=$(sed -n 's/^[[:space:]]*status:[[:space:]]*\(.*\)$/\1/p' notary_info.txt | tr 'A-Z' 'a-z' | head -n1)
            echo "Status: ${STATUS:-unknown}"
            if echo "$STATUS" | grep -q '^accepted'; then
              echo "✓ Accepted by Apple after $ELAPSED seconds"; break;
            fi
            if echo "$STATUS" | grep -q '^invalid'; then
              echo "✗ Invalid submission. Fetching detailed log..."
              xcrun notarytool log "$SUBMISSION_ID" --key AuthKey.p8 --key-id "$AC_API_KEY_ID" --issuer "$AC_API_ISSUER_ID" | tee notary_log.txt
              exit 1
            fi
            if [ $i -lt $ATTEMPTS ]; then
              echo "Waiting ${SLEEP_SECS}s before next check..."
              sleep $SLEEP_SECS
            fi
          done
          if ! echo "$STATUS" | grep -q '^accepted'; then
            echo "✗ Timed out after $MAX_WAIT seconds waiting for notarization approval"; exit 1;
          fi

      - name: Staple and validate
        run: |
          # Staple the notarization ticket to the app bundle.
          # This embeds the ticket so the app can be verified offline without network access to Apple's servers.
          # The spctl command validates the signature and ticket (|| true to ignore any warnings).
          APP_DIR="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app"
          xcrun stapler staple "$APP_DIR"
          spctl -a -vv "$APP_DIR" || true

      - name: Re-zip stapled app for distribution
        run: |
          APP_DIR="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app"
          ZIP_PATH="./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app.zip"
          rm -f "$ZIP_PATH"
          ditto -c -k --sequesterRsrc --keepParent "$APP_DIR" "$ZIP_PATH"

      - name: Upload macOS artifact (signed+notarized)
        uses: actions/upload-artifact@v4
        with:
          name: macos-app
          path: ./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app.zip

  build:
    runs-on: windows-latest
    needs: build-macos

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get the version
        id: get_version
        run: |
          $version = (Select-String -Path ./AlbionDataAvalonia.Desktop/pkg/inno.iss -Pattern '#define MyAppVersion "(.*)"').Matches.Groups[1].Value
          echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "Found version: $version"
        shell: pwsh

      - name: Get diff
        id: get_diff
        run: |
          git fetch --tags
          # Try to get latest tag, but don't fail if none exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          CURRENT_COMMIT=$(git rev-parse HEAD)
          REPO_URL="https://github.com/JPCodeCraft/AlbionDataAvalonia"

          if [ -z "$LATEST_TAG" ]; then
            echo "No tags found. Using all commits for the log."
            # Get all commits or limit to a reasonable number
            COMMIT_LOG=$(git log --max-count=20 --pretty=format:"[%h]($REPO_URL/commit/%H) - %s")
          else
            echo "Found tag: $LATEST_TAG"
            COMMIT_LOG=$(git log --pretty=format:"[%h]($REPO_URL/commit/%H) - %s" $LATEST_TAG..$CURRENT_COMMIT)
            if [ -z "$COMMIT_LOG" ]; then
              COMMIT_LOG="No new commits since the last release."
            fi
          fi

          COMMIT_LOG=${COMMIT_LOG//$'\n'/<br>}
          echo "Latest Tag: ${LATEST_TAG:-None}"
          echo "Current Commit: $CURRENT_COMMIT"
          echo "Commit Log: $COMMIT_LOG"
          echo "COMMIT_LOG=$COMMIT_LOG" >> $GITHUB_ENV
        shell: bash

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"
          dotnet-quality: "preview"

      - name: Install zip
        run: choco install zip -y
        shell: pwsh

      - name: Publish projects (Windows and Linux)
        run: |
          dotnet publish ./AlbionDataAvalonia.Desktop/AlbionDataAvalonia.Desktop.csproj --configuration Release
          dotnet publish ./AlbionDataAvalonia.Desktop.Linux/AlbionDataAvalonia.Desktop.Linux.csproj --configuration Release

      - name: Download macOS artifact
        uses: actions/download-artifact@v4
        with:
          name: macos-app
          path: AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish

      - name: Compile .ISS to .EXE Installer
        uses: Minionguyjpro/Inno-Setup-Action@v1.2.7
        with:
          path: AlbionDataAvalonia.Desktop/pkg/inno.iss
          options: /O+

      - name: Create Tag
        if: ${{ !(github.event_name == 'workflow_dispatch' && github.event.inputs.draft == 'true') }}
        id: create_tag
        run: |
          git tag v.${{ env.VERSION }}
          git push origin v.${{ env.VERSION }}
        shell: pwsh

      - name: Create Release and Upload Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NOTES=$(printf "Changes since last release:\n%s" "${{ env.COMMIT_LOG }}")
          DRAFT_ARG=""
          TAG="v.${{ env.VERSION }}"
          TITLE="Albion Free Market Data Client v.${{ env.VERSION }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.draft }}" = "true" ]; then
            DRAFT_ARG="--draft"
            TAG="v.${{ env.VERSION }}-draft-${GITHUB_RUN_ID}"
            TITLE="$TITLE (draft ${GITHUB_RUN_ID})"
          fi
          gh release create "$TAG" \
            "C:/Users/runneradmin/Documents/Inno Setup Output/AFMDataClientSetup_v_${{ env.VERSION }}.exe#AFMDataClientSetup_v_${{ env.VERSION }}.exe" \
            "./AlbionDataAvalonia.Desktop.Linux/bin/Release/net10.0/linux-x64/publish/AFMDataClient_Linux64#AFMDataClient_Linux64" \
            "./AlbionDataAvalonia.Desktop.Linux/bin/Release/net10.0/linux-x64/publish/AFMDataClient_Linux64_Installer.sh#AFMDataClient_Linux64_Installer.sh" \
            "./AlbionDataAvalonia.Desktop.Linux/bin/Release/net10.0/linux-x64/publish/AFMDataClient_Linux64_Uninstaller.sh#AFMDataClient_Linux64_Uninstaller.sh" \
            "./AlbionDataAvalonia.Desktop.MacOS/bin/Release/net10.0/osx-arm64/publish/AFMDataClient_MacOS64.app.zip#AFMDataClient_MacOS64.app.zip" \
            --title "$TITLE" \
            --notes "$NOTES" $DRAFT_ARG
        shell: bash

      - name: Create LatestVersion.json
        if: ${{ !(github.event_name == 'workflow_dispatch' && github.event.inputs.draft == 'true') }}
        run: |
          $version = "${{ env.VERSION }}"
          $json = @{ version = $version } | ConvertTo-Json
          $json | Out-File -FilePath ./AlbionDataAvalonia.Desktop/LatestVersion.json -Encoding utf8
        shell: pwsh

      - name: Commit and push changes
        if: ${{ !(github.event_name == 'workflow_dispatch' && github.event.inputs.draft == 'true') }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add ./AlbionDataAvalonia.Desktop/LatestVersion.json
          git commit -m "Update LatestVersion.json"
          git push
